# 98. Validate Binary Search Tree
Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

* The left subtree of a node contains only nodes with keys less than the node's key.
* The right subtree of a node contains only nodes with keys greater than the node's key.
* Both the left and right subtrees must also be binary search trees.
## DFS
```PYTHON
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        lower, upper = float("-inf"), float("inf")

        def dfs(node, l, r):
            if node is None:
                return True
            else:
                if not (l < node.val and node.val < r):
                    return False
                return dfs(node.left, l, node.val) and dfs(node.right, node.val, r)

        return dfs(root, lower, upper)
```
* Time Complexity: $O(n)$
* Space Complexity: $O(n)$
## BFS
```PYTHON
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        q = deque()
        if root:
            q.append([root, float("-inf"), float("inf")])
        while q:
            node, l, r = q.popleft()
            if not (l < node.val and node.val < r):
                return False
            if node.left:
                q.append([node.left, l, node.val])
            if node.right:
                q.append([node.right, node.val, r])
        return True
```
* Time Complexity: $O(n)$
* Space Complexity: $O(n)$
